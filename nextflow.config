manifest {
    mainScript = 'main.nf'
}

params {
    max_cores = Runtime.runtime.availableProcessors()
    cores = "1"
    memory = 8.GB

    /* input */
    reads = ''
    genome = ''
    augustus_species = 'my_species'
    rm_species = ''
    species = 'mammalia'
    busco_db = ''
    rmdb_name = 'rmdb'
    proteins_dir = ''
    rm_lib = ''
    augustus_config =''
    evm_weights=''
    pasa_config=''

    /* control config */

    /* tools config */
    seqkit_additional_params = '--threads 2'
    fastp_additional_params = ''
    rm_search_engine='rmblast'
    repeatmasker_additional_params = ' -s -no_is -norna -nolow'
    repeatproteinmasker_additional_params = ' -noLowSimple -pvalue 1e-04'
    busco_additional_params = ''
    augustus_additional_params = ''
    //glimmer_additional_params =''
    exonerate_additional_params ='--minintron 20 --maxintron 600000'
    fastp_additional_params = ''
    pasa_additional_params = '--ALIGNERS blat -I 600000'
    
    /* folder structure */
    output = 'results'
    seqkit_dir = 'preprocess/seqkit'
    busco_dir = 'preprocess/busco'
    fastp_dir = 'preprocess/fastp'
    repeatmasker_dir = 'repeat_annotation/repeatmasker'
    repeatmodeler_dir = 'repeat_annotation/repeatmodeler'
    repeatproteinmasker_dir = 'repeat_annotation/repeatproteinmasker'
    repeatannotation_dir = 'repeat_annotation'
    augustus_dir = 'de_novo_pred/augustus'
    glimmer_dir = 'de_novo_pred/glimmerhmm'
    exonerate_dir = 'homology_pred/exonerate'
    evidencemodeler_dir = 'evidencemodeler'
    hisat2_dir = 'transcriptome_pred/hisat2'
    trinity_dir = 'transcriptome_pred/trinity'
    pasa_dir = 'transcriptome_pred/pasa'
    

    // location for autodownload data like databases
    permanentCacheDir = 'nextflow-autodownload-databases'
    // location for storing the conda environments
    condaCacheDir = 'conda'
    // location for storing the singularity images
    singularityCacheDir = 'singularity'

}

profiles {

    /* executor */
    local {
        executor {
            name = "local"
            cpus = params.max_cores
            memory = params.memory
        }
        params.cloudProcess = false
        includeConfig 'conf/local.config'
    }

    slurm {
        executor {
            name = "slurm"
            cpus = params.max_cores
            memory = params.memory
        }
        params.cloudProcess = true
        process.cache = "lenient"
        includeConfig 'conf/cluster.config'
    }

    /* env engine */
    conda {
        conda {
            cacheDir = params.condaCacheDir
            timeout = '45 min'
            useMamba = true // use mamba to accelerate conda create and download
            enabled = true
        }
        docker.enabled = false
        singularity.enabled = false
        includeConfig 'conf/conda.config'
    }

    docker {
        enabled = true
        conda.enabled = false
        singularity.enabled = false
    }
    
    singularity {
        enabled = true
        docker.enabled = false
        conda.enabled = false

        autoMounts = true
        cacheDir = params.singularityCacheDir
}
    
    
}

// trace {
//     enabled = true
//     file = 'pipeline_trace.txt'
//     fields = 'task_id,process,name,status,exit,realtime,%cpu,memory,vmem,rss,peak_rss,disk'
// }

// dag {
//     enabled = true
//     file = 'pipeline_dag.html'
// }

// Function to ensure that resource requirements don't go beyond
// a maximum limit
def check_max(obj, type) {
    if (type == 'memory') {
        try {
            if (obj.compareTo(params.max_memory as nextflow.util.MemoryUnit) == 1)
                return params.max_memory as nextflow.util.MemoryUnit
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max memory '${params.max_memory}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'time') {
        try {
            if (obj.compareTo(params.max_time as nextflow.util.Duration) == 1)
                return params.max_time as nextflow.util.Duration
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max time '${params.max_time}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'cpus') {
        try {
            return Math.min( obj, params.max_cpus as int )
        } catch (all) {
            println "   ### ERROR ###   Max cpus '${params.max_cpus}' is not valid! Using default value: $obj"
            return obj
        }
    }
}